initSidebarItems({"constant":[["PUBLICKEYBYTES","Number of bytes in a `PublicKey`."],["SECRETKEYBYTES","Number of bytes in a `SecretKey`."],["SEEDBYTES","Number of bytes in a `Seed`."],["SIGNATUREBYTES","Number of bytes in a `Signature`."]],"fn":[["gen_keypair","`gen_keypair()` randomly generates a secret key and a corresponding public key."],["keypair_from_seed","`keypair_from_seed()` computes a secret key and a corresponding public key from a `Seed`."],["sign","`sign()` signs a message `m` using the signer's secret key `sk`. `sign()` returns the resulting signed message `sm`."],["sign_detached","`sign_detached()` signs a message `m` using the signer's secret key `sk`. `sign_detached()` returns the resulting signature `sig`."],["verify","`verify()` verifies the signature in `sm` using the signer's public key `pk`. `verify()` returns the message `Ok(m)`. If the signature fails verification, `verify()` returns `Err(())`."],["verify_detached","`verify_detached()` verifies the signature in `sig` against the message `m` and the signer's public key `pk`. `verify_detached()` returns true if the signature is valid, false otherwise."]],"mod":[["ed25519","`ed25519`, a signature scheme specified in Ed25519. This function is conjectured to meet the standard notion of unforgeability for a public-key signature scheme under chosen-message attacks."]],"struct":[["PublicKey","`PublicKey` for signatures"],["SecretKey","`SecretKey` for signatures"],["Seed","`Seed` that can be used for keypair generation"],["Signature","Detached signature"],["State","State for multi-part (streaming) computation of signature."]]});